EXPLICATION DES REQUÊTES - ROUTES :

// route post -  pour créer un utilisateur
router.post('/', async (req, res) => {   
    const { username, email, password } = req.body; 

    try {
        const result = await db.query(
            'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING *',
            [username, email, password]
        );
        res.status(201).send(result.rows[0]);
    } catch (err) {
        console.error('❌ Erreur PostgreSQL :', err); 
        res.status(500).send({ error: `Erreur lors de la création de l'utilisateur`});
    }
});

Globalement, que fais ce code ?

1. Quand un client fait un POST sur /users avec un body contenant username, email, password :
2. On extrait ces données depuis res.body.
3. On envoie une requête SQL paramétréé à PostgreSQL pour insérer ces données.
4. PostgrSQL retourne la nouvelle ligne créée.
5. On renvoie cette ligne au client avec un code 201 si tout va bien.
6. Si une erreur survient, on log l'erreur et on renvoie un code 500.


* router
    * C'est une instance de Router importée depuis Express : import { Router } from ' express '.
    * Elle sert à définir des sous-routes que tu pourras ensuite utiliser dans server.use('/users', userRouter).
* .post()
    * Méthode d'Express qui défini une route HTTP POST (utilisée pour envoyer/créer des données).
* '/'
    * Chemin relatif de la route
    * Ici "/" signifie que si on appelle /users depuis l'API, ça va exécuter  ce code (car dans index.ts on a server.use('/users', userRouter)).
* async
    * Indique que la fonction sera asynchrone : elle pourra utiliser await pour attendre des opérations (ex: requête à la DB).
* (req, res) => {...}
    * C'est une fonction fléchée avec deux paramètres :
        * req (Request) : l'objet qui contient toutes les infos de la requêtes HTTP (body, params, headers...).
        * res (Response) : l'objet qui permet d'envoyer la réponses HTTP au client.


* const { username, email, password } = req.body;
* const 
    * Déclare une constante (variable qui ne pourra pas être réassigné à un autre objet, mais dont le contenu interne peut être modifié si c'est un objet).
* { username, email, password }
    * c'est de la déstructuration d'objet : on extrait directementces trois propriétés depuis 'req.body'.
* req.body
    * c'est l'objet contenant les données envoyées par lec lient dans la requête POST (généralement en JSON).
    exemple : si le client envoie {"username":"jule"}
        alors : 'username' vaut 'jule'

* try{}
    * bloc qui tente d'exécuter du code
    * s'il y a une erreur à l'intérieure, lexécution saute directement dans le catch.


*const result = await db.query(
'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING *',
[username, email, password]
);
    * const result =
        * stocke la valeur de retour dans une constante 'result'.
    * await
        * attend que la requête PostgrSQL finisse avant de passer à la suite.
        * sans 'await', on aurait une Promise non résolue.
    * db.query()
        *méthode de la conexion PostgrSQL qui envoie une requête SQL à la base.
    *SQL INSERT INTO...
        * INSERT INTO users (...) -> ajoute une nouvelle ligne dans la table users.
        *(username, email, password) -> colonnes dans lesquelles on insère les données.
        *VALUES ($1, $2, $3) -> valeurs à insérer, où $1 sera remplacé par un username, $2 par email, et $3 par password.
            On utilise cette syntaxe paramétrée pour éviter les failles SQL Injection
        * RETURNING -> PostgrSQL renvoie la ligne qu'il vient d'insérer.
        * [username, email, password]
            * Tableau des valeurs qui remplacent $1, $2, $3 dans la requête.

*res.status(201).send(result.rows[0])
*res
    * objet réponses Express
*.status(201)
    * Définit le code HTTP de la réponse.
    * 201 = "Created" (ressource créée avec succès).
*.send(...)
    * Envoie une réponse au client.
* result.rows[0]
    * result.rows = tableau contenant les lignes retournées par postgreSQL
    * [0] = on prend la première ligne (ici, l'utilisateur qu'on vient de créer).

* catch(err)
    * si une erreur arrive dans le bloc, on survient ici 
* res.status(500).send({ error: 'Erreur lors de la créaton de l'utilisateur'});
    * Renvoie un code HTTP 500 (erreur serveur)
    * Envoie un objet JSON contenant un message d'erreur.