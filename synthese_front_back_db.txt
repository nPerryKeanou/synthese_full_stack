1. Comprendre le rôle des couches.

    ° Front-end (React Native + TypeScript)
        -> C'est ton app mobile, l'interface utilisateur. Elle envoie des requêtes HTTP (via Axios) vers ton serveur, et affiche les réponses.
    ° Back-end (Express + Node.js)
        -> C'est ton API. Il reçoit les requêtes, vérifie les données, fait appel à la base de données, et renvoie un résultat formaté (souvent JSON).
    ° Database (SQL)
        -> C'est là où les utilisateurs sont stockés (login, mot de passe hashé, etc). Le back-end est le seul à dialoguer directement avec elle.

2.  Flux typique d'une requpete.

    Exemple avec login :
        1. L'utilisateur entre son email/mot de passe dans ton app.
        2. Ton front envoi une requpete POST/login via Axios.
        3. Express reçoit la requête -> valide les données -> exécute une requête SQL (via un client type pg, mysql2 ou sequelize).
        4. La database renvoie la ligne correspondante.
        5. Express vérifie que le mot de passe est correct, puis génère une réponse (ex. Un JWT ou un objet utilisateur).
        6. Ton front reçoit la réponse et met à jour l'UI.

3.  Points à vérifier pour connecter les trois.

    ° URL/API: le front doit appeler l'URL du serveur Express (ex. http://localhost:3000/login en dev, une vrai IP/DOMAINE plus tard).
    ° Middleware: assure-toi qu'Express peut lire le body JSON (express.json()).
    ° CORS: si ton app tourne en mode dev, il faut autoriser ton front à contacter ton back (cors middleware dans express).
    ° Connexion DB: ton back doit avoir une connexion stable à la base (pool de connexion recommandé).
    ° Getion des erreurs: Prévois des réponses claires côté back pour que le front sache quoi afficher.

4.  Étapes pratiques pour tester.

    1. Tester chaque couche isolée:
        ° Avec curl ou postman, envoie une requpete à ton back -> voir si la DB répond bien.
        ° Avec ton app React Native, test que les inputs déclenchent bien les appels Axios.
    2. Brancher le front au back:
        ° Configure Axios pour pointer vers ton serveur Express.
        ° Vérifie que tu récupères bien la réponses attendue (ex. console.log coté front).
    3. Scénario de bout en bout.
        ° Lance la DB, le serveur Express, et l'app mobile.
        ° Faire un login/register depuis l'app -> suivre la requête jusqu'à la DB -> regarde la réponse dans l'app.
    

####################################################################################################################################################

ORGANISATION DU FRONT REACT NATIVE
- - - - - - - - - - - - - - - - - 

1. Service (Axios & API calls)
    ° Création du dossier servies/
    ° Dans ce dossier, on met un fichier par "domaine" (ex: authService.ts, userService.ts).
    ° Chaque fichier contient les fonctions qui appellent ton back via Axios (login, register, getProfil, etc).
    ° Avantage: ton UI n'a pas besoin de savoir "comment" l'appel est fait, elle utilise jsute authServices.login(...).

2. Context (gestion de l'état global, ex. AuthContect)
    ° Comme tu as une app mobile, l'utilisateur sera probablement connecté sur plusieurs écrans.
    ° Crée un AuthContext (ou un store avec Zustand/Redux pour aller plus loin).
    ° Ce context contient:
        .L'état de l'utilisateur (connecté ? Infos du user ? Token ?),
        .Les fonctions login() et logout() qui utilisent ton authService.
    ° Avantage: tu centralises la logique d'auth, et tu peux l'utiliser partout dans ton app sans dupliquer du code.

3. UI (screens et components)
    ° Tes écrans (ex. LoginScreen.tsx, RegisterScreen.tsx) s'occupent uniquement de l'interface:
        . champs de formulaire,
        . boutons,
        . affichage d'erreurs ou succès.
    ° Quand un bouton est cliqué -> il appelle une fonction du contect (qui lui-même appelle le service).
    ° Avantage: les écrans ne gèrent pas la logique réseau directement.

Exemple de flux logique:
    1. LoginScreen -> bouton pressé -> appelle authContect.login(email, password)
    2. authContext.login -> appelle authService.login(email, password)
    3. authService.login -> fait la requête Axios vers ton back -> renvoie une réponse
    4. authContext -> met à jour l'état global (user, token)
    5. UI -> se met à jour automatiquement (ex: reirection vers HomeScreen)

Avantages de cette structure:
    . Lisibilité: chaque couche a un rôle clair (UI, état global, API calls)
    . réutilisable: tes services peuvent être utilisé dans plusieurs contextes (ex: un service userService pour fetch un profil ou uptadte un avatar)
    . Facile à tester: on peut tester les services séparément, le context séparément, etc.