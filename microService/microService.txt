üèóÔ∏è 1. Le Principe des Microservices
Le concept de Microservices est une approche d'architecture logicielle qui s'oppose au mod√®le monolithique traditionnel.

Caract√©ristique	Monolithe (Avant)	Microservices (Maintenant)
Structure	Une seule application massive contenant toute la logique (utilisateurs, produits, commandes, facturation...).	Une collection de petits services ind√©pendants, chacun ex√©cutant un processus unique.
D√©ploiement	L'application enti√®re doit √™tre red√©ploy√©e pour la moindre modification.	Chaque service peut √™tre d√©ploy√©, mis √† jour et g√©r√© ind√©pendamment.
Technologies	G√©n√©ralement un seul langage et une seule base de donn√©es pour tout.	Chaque service peut utiliser la technologie la plus adapt√©e √† sa fonction (ex: Python pour l'IA, Java pour la rapidit√©, Node.js pour le temps r√©el).
√âquipe	Une seule grande √©quipe travaille sur l'ensemble du code.	Des petites √©quipes (souvent appel√©es "feature teams") sont responsables de A √† Z d'un ou deux services seulement.
L'Objectif

L'objectif principal des microservices est d'am√©liorer la scalabilit√©, la r√©silience (si un service tombe, le reste de l'application continue de fonctionner), et la vitesse de d√©veloppement/d√©ploiement.

üö™ 2. L'API Gateway : Le Portier du Syst√®me
Lorsque vous avez des dizaines de microservices, les clients (application mobile, site web) ne peuvent pas se connecter directement √† chacun. C'est l√† qu'intervient l'API Gateway.

L'API Gateway est une couche de service unique qui agit comme le point d'entr√©e frontal de votre architecture. C'est le seul composant qui est expos√© √† l'ext√©rieur.

R√¥les Cl√©s de l'API Gateway

Routage et Orchestration :

Le client envoie une seule requ√™te simple (ex: GET /mon-compte).

L'API Gateway d√©termine quel microservice interne doit traiter cette requ√™te (ex: le service Utilisateur et le service Historique).

Dans les cas complexes, l'API Gateway peut m√™me orchestrer plusieurs appels internes et agr√©ger les donn√©es de diff√©rents services avant de renvoyer une r√©ponse unique et format√©e au client.

S√©curit√© et Authentification :

L'API Gateway est le point id√©al pour g√©rer la s√©curit√©. Elle v√©rifie si l'utilisateur est bien authentifi√© (v√©rification du jeton JWT ou de la cl√© API) avant de transf√©rer la requ√™te aux microservices internes. Cela prot√®ge tous les services derri√®re un seul mur.

Gestion du Trafic :

Elle g√®re la Limitation de D√©bit (Rate Limiting) pour emp√™cher les abus ou les attaques DDoS.

Elle peut g√©rer la mise en cache de certaines r√©ponses.

En R√©sum√©

Composant	R√¥le Cl√©	Analogie
Microservice	Ex√©cute une fonction m√©tier unique et sp√©cifique.	Le chef sp√©cialis√© (Service Facturation, Service Utilisateur).
API Gateway	Point d'entr√©e unique qui achemine, s√©curise et agr√®ge les requ√™tes client.	L'accueil / Le standardiste de l'entreprise.
En utilisant l'API Gateway, l'application cliente gagne en simplicit√©, et l'architecture gagne en s√©curit√© et en performance.



Microservice et port :
    Dans les microservices (ex: user-service, product-service, order-service), ils utilisent tous les m√™mes port dans leurs propre containeur. (ex :3000).
        * Raison : chaque service est une appplciation nodejs isol√©. C'est une convention courante que de d√©marrer une application sur un port 3000. Puisque chaque serveur vit dans 
                    son propre environnement, ils peuvent √©couter tous sur le port :3000 sans conflits.
        * Identit√© sur les reseaux docker : Pour communiquer entre eux (par exemple de la gateway au user-service), les conteneurs utilisent leurs noms de services et le port interne. Le nom de l'identifiant est unique mais pas le port.
    
    Ce sont les ports externes qui sont diff√©rent :
    Les ports externes : le Mapping (3001, 3002, 3003).
        C'est ici qu'intervient la distinction. Les ports, 3001,3002,3003 sont des ports que l'on utilise pour acc√©der √† chaque services depuis la machine h√¥te.
        Le fichier docker-compose.yml g√®re ce mapping:
            ports:
                - "3001:3000"  # Format : [Port H√îTE]:[Port CONTENEUR]

            port 3001, c'est le port de l'hote, de la machine.
            port 3000, c'est le port du microservice.
            || 'http://localhost:3001' : C'est le fallback. Si vous d√©marrez le serveur de la Gateway seul sur votre Mac, il suppose qu'il peut trouver le service Users sur le port externe de l'h√¥te, qui est 3001.

C'est pourquoi les ports du localhost sont diff√©rents : ils refl√®tent le port externe unique que Docker utilise pour √©viter les conflits sur votre



--------------------------------------------------------------
Avoir configur√© les URLs dans votre docker-compose.yml signifie que l'√âtape 1 est pr√™te √† √™tre finalis√©e.

Vous devez maintenant √©diter le fichier api-gateway/src/app.ts pour y ajouter les configurations de proxy manquantes pour les services Products et Orders.

----------------------------------------------------------------



Code	Explication	Concept / R√¥le dans le Challenge
import { Request, Response, NextFunction } from 'express';	Importe les interfaces de types d'Express pour garantir que req, res, et next ont la structure attendue.	TypeScript/Express : Permet la typographie stricte des fonctions middleware.
import jwt from 'jsonwebtoken';	Importe la librairie JWT (JSON Web Token) utilis√©e pour signer et, ici, v√©rifier les tokens.	S√©curit√© : L'outil essentiel pour d√©coder le token.
`const JWT_SECRET = process.env.JWT_SECRET		'mysupersecretkey';`
interface JwtPayload { ... }	D√©finit la structure attendue du payload (les donn√©es utiles) √† l'int√©rieur du token JWT.	TypeScript : Permet √† TS de savoir qu'apr√®s d√©codage, l'objet aura au moins les propri√©t√©s userId et role.
export const authenticate = (req: Request, res: Response, next: NextFunction) => { ... };	Exporte la fonction middleware principale. Elle prend les objets de requ√™te (req), de r√©ponse (res), et la fonction de passage (next).	Express Middleware : Le point d'entr√©e de la logique d'authentification.
const authHeader = req.headers.authorization;	Tente de r√©cup√©rer la valeur du header HTTP Authorization. C'est l√† que le client envoie le JWT, souvent sous la forme Bearer <TOKEN>.	JWT Standard : Emplacement standard du token dans les requ√™tes API.
`if (!authHeader		!authHeader.startsWith('Bearer ')) { ... }`
return res.status(401).json({ message: 'Acc√®s refus√©. Token manquant ou mal form√©.' });	Si la v√©rification √©choue, la requ√™te est imm√©diatement bloqu√©e et renvoie une erreur 401 Unauthorized.	S√©curit√© : Rejette les requ√™tes non authentifi√©es.
const token = authHeader.split(' ')[1];	S√©pare la cha√Æne Bearer <TOKEN> en deux √©l√©ments et isole le token r√©el ([1]).	Extraction : Isole la partie du token n√©cessaire √† la v√©rification.
try { ... } catch (error) { ... }	Un bloc try...catch est indispensable car jwt.verify peut lancer une exception si le token est invalide ou expir√©.	Gestion d'Erreur : N√©cessaire pour g√©rer les probl√®mes de s√©curit√© sans faire planter l'application.
const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;	C'est le c≈ìur de l'authentification. Il v√©rifie la signature du token avec la JWT_SECRET et s'assure qu'il n'est pas expir√©. Si tout est bon, il retourne le payload d√©cod√©.	Validation JWT : Confirme que le token est authentique et non alt√©r√©.
req.headers['x-user-id'] = decoded.userId;	Ajoute l'ID utilisateur, extrait du payload d√©cod√©, √† un nouveau header appel√© x-user-id.	Enrichissement (Point 3) : Transmet l'information d'identit√© au microservice cible.
req.headers['x-user-role'] = decoded.role;	Ajoute le r√¥le de l'utilisateur √† un nouveau header appel√© x-user-role.	Enrichissement (Point 3) : Transmet l'information d'autorisation au microservice cible.
next();	Si l'ex√©cution arrive ici, l'authentification est r√©ussie. La fonction appelle next() pour permettre √† Express de passer au middleware suivant (qui sera le proxy).	Continuation : Laisse la requ√™te atteindre sa destination finale (le proxy pour le routage).
return res.status(401).json({ message: 'Token invalide ou expir√©.' });	Si le try √©choue (par exemple, token expir√© ou cl√© secr√®te incorrecte), cette ligne est ex√©cut√©e.	Rejet Final : Bloque la requ√™te si la v√©rification cryptographique √©choue.